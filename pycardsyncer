#!/usr/bin/env python
# coding: utf-8
# vim: set ts=4 sw=4 expandtab sts=4:
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <geier@lostpackets.de> wrote this file. As long as you retain this notice you
# can do whatever you want with this stuff. If we meet some day, and you think
# this stuff is worth it, you can buy me a beer in return Christian Geier
# ----------------------------------------------------------------------------


##############################
# imports {{{

#from IPython.Debugger import Tracer; debug_here = Tracer()
import StringIO
import sys
import getopt
import signal
from os import path

import ConfigParser
from ConfigParser import SafeConfigParser

try:
    import vobject
except ImportError:
    print "py-vobject not installed"
    sys.exit(1)

try:
    import lxml.etree as ET
except:
    print "py-lxml not installad"
    sys.exit(1)

try:
    import pycurl
except:
    print "pycurl not installed"
    sys.exit(1)


try:
    import sqlite3
except:
    print "pysqlite3 not installed"
    sys.exit(1)

# /imports
###########################}}}

class Configuration:
    """The pycardsyncer configuration interface.

    The Configuration is a collection of items which take their value
    from a ConfigParser object. It is possible to access the
    configuration item values as if they were a property of the
    Configuration object. Those property are identified using the item
    section and name, with the following format: section_name.

    The configuration can check the defined items are not missing from
    the configuration file, and can dump itself on output.
    """

    DAV_SECTION = 'dav'
    DB_SECTION = 'database'
    DEFAULT_SECTION = 'default'
    DEFAULT_DB_PATH = '~/.pycard/abook.db'
    DEFAULT_FILE="~/.pycard/pycard.conf"

    class Item(object):
        """A configuration item abstraction.

        Each configuration item is defined with its key name, and the
        section it belongs to. An item is able to return its value
        using a parser function, and then possibly a filter function.
        """
        def __init__(self, section, key, parser, filter_=None):
            self._section = section
            self._key = key
            self._parser = parser
            self._filter = filter_ if filter_ is not None else lambda x: x

        def read(self):
            return self._filter(self._parser(self.section, self.key))

        @property
        def section(self):
            return self._section

        @property
        def key(self):
            return self._key

    def __init__(self, config_file):
        """Parse the given file, and setup the configuration items.

        ConfigParser.Error (or one of its subclasses) is raised on
        parsing error."""
        self._parser = SafeConfigParser()
        self._parser.read(config_file) self._items = {}

        self._add_item(Configuration.Item(Configuration.DAV_SECTION, 'user', self._parser.get))
        self._add_item(Configuration.Item(Configuration.DAV_SECTION, 'passwd', self._parser.get))
        self._add_item(Configuration.Item(Configuration.DAV_SECTION, 'server', self._parser.get))
        self._add_item(Configuration.Item(Configuration.DAV_SECTION, 'resource', self._parser.get))
        self._add_item(Configuration.Item(Configuration.DAV_SECTION, 'base_url', self._parser.get))
        self._add_item(Configuration.Item(Configuration.DAV_SECTION, 'insecure_ssl', self._parser.getboolean))
        self._add_item(Configuration.Item(Configuration.DB_SECTION, 'path', self._parser.get, path.expanduser))

    def __getattr__(self, name):
        item = self._items.get(name)
        if item is not None:
            return item.read()

        raise AttributeError(name)

    def _add_item(self, item):
        self._items['_'.join([item.section, item.key])] = item

    @property
    def debug(self):
        return self._parser.getboolean(Configuration.DEFAULT_SECTION, 'debug')

    def check(self, debug):
        if not self._parser.has_option(Configuration.DB_SECTION, 'path'):
            self._parser.set(Configuration.DB_SECTION, 'path', Configuration.DEFAULT_DB_PATH)
        if debug:
            self._parser.set(Configuration.DEFAULT_SECTION, 'debug', True)

        result = True
        for item in self._items.values():
            try:
                item.read()
            except ConfigParser.NoOptionError:
                print 'Mandatory option [%s] %s is missing' % (item.section, item.key)
                result = False

        return result

    def dump(self):
        """Dump the loaded configuration.

        The value displayed here are the exact values which seen by
        the program, and not the raw values as they are read in the
        configuration file."""
        print "Using configuration:"
        for item in self._items.values():
            if item.section == Configuration.DAV_SECTION and item.key == 'passwd':
                print '[%s] %s: XXXXX' % (item.section, item.key)
            else:
                print '[%s] %s: %s' % (item.section, item.key, item.read())
        print "\n"

##############################################
# database creation foo {{{

def makeTables():
    conn = sqlite3.connect(conf.database_path)
    c = conn.cursor()
    try:
            c.execute('''CREATE TABLE version        (
                    version INTEGER
                    )''')
            if conf.debug:
                    print "created version table"
    except sqlite3.OperationalError as detail:
        if conf.debug:
            print detail
    except:
            sys.stderr.write('Failed to connect to database, Unknown Error')
    conn.commit()

    # VERSION information
    database_version = 1
    c.execute('SELECT version FROM version')
    result = c.fetchone()
    if result == None:
        t = (database_version,)
        c.execute('INSERT INTO version (version) VALUES (?)',t)
        conn.commit()
    elif not result[0] == database_version:
         sys.exit(str(conf.database_path) + " is probably not a valid or an "
            "outdated database.\nYou should consider to remove it and "
            "sync again using pycardsyncer.\n")

    try:
            c.execute('''CREATE TABLE vcardtable        (
                    href TEXT PRIMARY KEY NOT NULL,
                    etag TEXT,
                    name TEXT
                    )''')
            if conf.debug:
                    print "created vcards table"
    except sqlite3.OperationalError as detail:
        if conf.debug:
            print detail
    except:
            sys.stderr.write('Failed to connect to database, Unknown Error')
    conn.commit()

    # properties table
    try:
            c.execute('''CREATE TABLE properties(
            id INTEGER PRIMARY KEY NOT NULL,
            property TEXT NOT NULL,
            value TEXT,
            href TEXT NOT NULL,
            FOREIGN KEY(href) REFERENCES vcardtable(href)
            )''')
            if conf.debug:
                    print "created properties table"
    except sqlite3.OperationalError as detail:
            if conf.debug:
                    print detail
    except:
            sys.stderr.write('Failed to connect to database, Unknown Error')
    conn.commit()

    # parameter table
    try:
            c.execute('''CREATE TABLE parameters(
            parameter TEXT NOT NULL,
            value TEXT,
            href TEXT NOT NULL,
            property_id INTEGER NOT NULL,
            FOREIGN KEY(href) REFERENCES vcardtable(href),
            FOREIGN KEY(property_id) REFERENCES properties(id)
            )''')
            if conf.debug:
                    print "created parameters table"
    except sqlite3.OperationalError as detail:
            if conf.debug:
                    print detail
    except:
            sys.stderr.write('Failed to connect to database, Unknown Error')
    conn.commit()

    c.close()

    c.close()

# /database foo }}}
##############################################

def smartencode(s):
    unicode(s).encode("utf-8", "strict")

def usage():
    print """usage: pycardsyncer [options]
       pycardsyncer --help/-h       show this help text
       pycardsyncer --version/-v    show version
options: 
  -c <file>/--config=<file> location of config file
                            default: ~/.pycard/pycard.config
  --debug show some debugging output"""

def version():
    print "0.3.3"

def getXMLProps():
    response=StringIO.StringIO()
    header=StringIO.StringIO()
    c = pycurl.Curl()
    c.setopt(pycurl.WRITEFUNCTION, response.write)
    c.setopt(pycurl.HEADERFUNCTION, header.write)
    c.setopt(pycurl.USERPWD, conf.dav_user + ":" + conf.dav_passwd)
    c.setopt(pycurl.URL, conf.dav_resource)
    if (conf.dav_insecure_ssl):
        c.setopt(pycurl.SSL_VERIFYPEER, 0)
    c.setopt(pycurl.SSLVERSION, pycurl.SSLVERSION_SSLv3)
    c.setopt(pycurl.CUSTOMREQUEST, "PROPFIND")
    c.perform()
    c.close
    header =  header.getvalue()
    xml = response.getvalue()
    if (header.find("addressbook") == -1):
        print "URL is not a CardDAV resource"
        sys.exit(1)
    return xml

def processXMLProps(xml):
    namespace="{DAV:}"
    element = ET.XML(xml)
    abook = dict()
    for response in element.iterchildren():
        if (response.tag == namespace+"response"):
            href = ""
            etag = ""
            insert = False
            text = {
                'davical' : "text/vcard",
                'sabredav' : "text/x-vcard"
            }[conf.dav_server]
            for refprop in response.iterchildren():
                if (refprop.tag == namespace+"href"):
                    href = refprop.text
                for prop in refprop.iterchildren():
                    for props in prop.iterchildren():
                        if (props.tag == namespace+"getcontenttype" and props.text == text):
                            insert = True
                        if (props.tag == namespace+"getetag"):
                            etag = props.text
                        #print("%s - %s" % (props.tag, props.text))
                    if insert:
                        abook[href] = etag
    return abook

def checkNewEtag(vRef, vEtag):
    """returns True when the etag has been updated, otherwise False"""
    conn = sqlite3.connect(conf.database_path)
    c = conn.cursor()
    t = (vRef,)
    c.execute('SELECT etag FROM vcardtable WHERE href=(?);',t)
    if vEtag==c.fetchall()[0][0]:
        returnCode=False
    else:
        returnCode=True
    conn.commit()
    c.close()
    return returnCode

def checkVRefExists(vRef):
    conn = sqlite3.connect(conf.database_path)
    c = conn.cursor()
    t=(vRef,)
    c.execute('SELECT count(*) FROM vcardtable WHERE href=(?);',t)
    if c.fetchall()==[(1,)]:
        returnCode=False
    else:
        returnCode=True
    conn.commit()
    c.close()
    return returnCode

def insertVRef(vRef):
    """inserts vRef into the vcardtable"""
    conn = sqlite3.connect(conf.database_path)
    c = conn.cursor()
    t =(vRef,)
    c.execute('INSERT INTO vcardtable (href) VALUES (?);', t)
    conn.commit()
    c.close()

def updateEtag(vRef, vEtag):
    conn = sqlite3.connect(conf.database_path)
    c = conn.cursor()
    t =(vEtag,vRef,)
    c.execute('UPDATE vcardtable SET etag=(?) WHERE href=(?);',t)
    conn.commit()
    c.close()
    return True

def insertName(vRef,name):
    conn = sqlite3.connect(conf.database_path)
    c = conn.cursor()
    t =(name, vRef)
    c.execute('UPDATE vcardtable SET name=(?) WHERE href=(?)',t) 
    conn.commit()
    c.close()

def deleteVcardFromDb(vRef):
    conn = sqlite3.connect(conf.database_path)
    c = conn.cursor()
    t =(vRef,)
    c.execute('DELETE from properties WHERE href=(?)',t) 
    c.execute('DELETE from parameters WHERE href=(?)',t) 
    conn.commit()
    c.close()

def getVcard(vRef):
    response=StringIO.StringIO()
    header=StringIO.StringIO()
    c = pycurl.Curl()
    c.setopt(pycurl.SSLVERSION, pycurl.SSLVERSION_SSLv3)
    c.setopt(pycurl.WRITEFUNCTION, response.write)
    c.setopt(pycurl.HEADERFUNCTION, header.write)
    c.setopt(pycurl.USERPWD, conf.dav_user + ":" + conf.dav_passwd)
    c.setopt(pycurl.URL, conf.dav_base_url + vRef)
    if (conf.dav_insecure_ssl):
        c.setopt(pycurl.SSL_VERIFYPEER, 0)
    c.perform()
    c.close

    header =  header.getvalue()
    vCard = response.getvalue()
    
    find = {
        'davical' : "addressbook",
        'sabredav' : "text/x-vcard"
    }[conf.dav_server]

    if (header.find(find) == -1):
        print "URL is not a CardDAV resource"
        sys.exit(1)

    return vCard

def insertVcardInDb(vRef,v):
    if v.name == "VCARD":
    #    v.prettyPrint()
        for line in v.getChildren():
            try:
                line.transformFromNative()
            except:
                pass

            propertyName = line.name
            propertyValue = line.value
            if (propertyName == "PHOTO"): # for now, we cannot handle photos
                pass
            else:
                conn = sqlite3.connect(conf.database_path)
                c = conn.cursor()
                t =(unicode(propertyName), unicode(propertyValue),vRef,)
                #if conf.debug:
                    #print "unicode(propertyName): ", unicode(propertyName), " type: ", type(unicode(propertyName))
                    #print "unicode(propertyValue): ", unicode(propertyValue), " type: ", type(unicode(propertyValue))
                    #print "vRef: ", vRef, " type: ", type(vRef)
                    #print "t: ", t, " type: ", type(t)

                c.execute('INSERT INTO properties (property, value, href) VALUES (?,?,?);', t)
                lastrowid = c.lastrowid
                if line.params:
                    for key in line.params.keys():
                        for keyValue in line.params[key]:
                            t =(key, keyValue,vRef,lastrowid)
                            c.execute('INSERT INTO parameters (parameter, value, href,property_id) VALUES (?,?,?,?);', t)
                            #print key + ": " + i
                conn.commit()
                c.close()
    else:
        return -1 # this is not a vcard


def signal_handler(signal, frame):
    sys.exit(0)

def main(argv):
    global conf
    configfile = Configuration.DEFAULT_FILE
    DEBUG=0
    try:
        opts, args = getopt.getopt(argv, "hc:v", ["help", "config=","version","debug"])
    except getopt.GetoptError:
        usage()
        sys.exit(1)

    for opt, arg in opts:
        if opt in ("-h","--help"):
            usage()
            sys.exit()
        elif opt in ("-v","--version"):
            version()
            sys.exit()
        elif opt == "--debug":
            DEBUG=1
        elif opt in ("-c","--config"):
            configfile=arg


    # trying to hide some ugly python code on pressing Ctrl-C
    signal.signal(signal.SIGINT, signal_handler)

    # Read configuration.
    try:
        configfile = path.expanduser(configfile)
        if DEBUG:
            print "reading config from ", configfile
        conf = Configuration(configfile)
        if not conf.check(DEBUG):
            sys.exit(1)
        if conf.debug:
            conf.dump()
    except ConfigParser.Error, e:
        print 'Could not read %s: %s' % (configfile, e)
        sys.exit(1)

    makeTables()

    # primitive XML processing
    xml = getXMLProps()

    abook = processXMLProps(xml)

    for vRef,vEtag  in abook.iteritems():
        if checkVRefExists(vRef):
            insertVRef(vRef)
        
        if checkNewEtag(vRef,vEtag):
            deleteVcardFromDb(vRef)
            if conf.debug:
                print "getting ", vRef, " etag: ", vEtag

            vcard = getVcard(vRef)
            v = vobject.readOne(vcard)

            # DEBUG
            #print v.prettyPrint()
            #print v.contents
            # /DEBUG
            

            # this is the important part
            try:
                insertVcardInDb(vRef,v)
                updateEtag(vRef, vEtag)
            except Exception, err:
                sys.stderr.write("ERROR: something went wrong while inserting VCard %s into the db" % str(vRef))
                sys.stderr.write('%s\n' % str(err))




if __name__ == "__main__":
    main(sys.argv[1:])

